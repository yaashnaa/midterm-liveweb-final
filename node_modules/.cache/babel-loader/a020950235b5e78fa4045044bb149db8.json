{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uServer = void 0;\n\nconst debug_1 = require(\"debug\");\n\nconst server_1 = require(\"./server\");\n\nconst transports_uws_1 = require(\"./transports-uws\");\n\nconst debug = (0, debug_1.default)(\"engine:uws\");\n\nclass uServer extends server_1.BaseServer {\n  init() {}\n\n  cleanup() {}\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n\n\n  prepare(req, res) {\n    req.method = req.getMethod().toUpperCase();\n    req.url = req.getUrl();\n    const params = new URLSearchParams(req.getQuery());\n    req._query = Object.fromEntries(params.entries());\n    req.headers = {};\n    req.forEach((key, value) => {\n      req.headers[key] = value;\n    });\n    req.connection = {\n      remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()\n    };\n    res.onAborted(() => {\n      debug(\"response has been aborted\");\n    });\n  }\n\n  createTransport(transportName, req) {\n    return new transports_uws_1.default[transportName](req);\n  }\n  /**\n   * Attach the engine to a µWebSockets.js server\n   * @param app\n   * @param options\n   */\n\n\n  attach(app\n  /* : TemplatedApp */\n  , options = {}) {\n    const path = this._computePath(options);\n\n    app.any(path, this.handleRequest.bind(this)) //\n    .ws(path, {\n      compression: options.compression,\n      idleTimeout: options.idleTimeout,\n      maxBackpressure: options.maxBackpressure,\n      maxPayloadLength: this.opts.maxHttpBufferSize,\n      upgrade: this.handleUpgrade.bind(this),\n      open: ws => {\n        const transport = ws.getUserData().transport;\n        transport.socket = ws;\n        transport.writable = true;\n        transport.emit(\"drain\");\n      },\n      message: (ws, message, isBinary) => {\n        ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n      },\n      close: (ws, code, message) => {\n        ws.getUserData().transport.onClose(code, message);\n      }\n    });\n  }\n\n  _applyMiddlewares(req, res, callback) {\n    if (this.middlewares.length === 0) {\n      return callback();\n    } // needed to buffer headers until the status is computed\n\n\n    req.res = new ResponseWrapper(res);\n\n    super._applyMiddlewares(req, req.res, err => {\n      // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n      req.res.writeHead();\n      callback(err);\n    });\n  }\n\n  handleRequest(res, req) {\n    debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n    this.prepare(req, res);\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(req.res, errorCode, errorContext);\n        return;\n      }\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\");\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(server_1.Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n\n  handleUpgrade(res, req, context) {\n    debug(\"on upgrade\");\n    this.prepare(req, res);\n    req.res = res;\n\n    const callback = async (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: server_1.Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        this.abortRequest(res, errorCode, errorContext);\n        return;\n      }\n\n      const id = req._query.sid;\n      let transport;\n\n      if (id) {\n        const client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          res.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          res.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          res.close();\n        } else {\n          debug(\"upgrading existing transport\");\n          transport = this.createTransport(req._query.transport, req);\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n\n        if (!transport) {\n          return;\n        }\n      } // calling writeStatus() triggers the flushing of any header added in a middleware\n\n\n      req.res.writeStatus(\"101 Switching Protocols\");\n      res.upgrade({\n        transport\n      }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n    };\n\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(server_1.Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n\n  abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? \"403 Forbidden\" : \"400 Bad Request\";\n    const message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];\n    res.writeStatus(statusCode);\n    res.writeHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify({\n      code: errorCode,\n      message\n    }));\n  }\n\n}\n\nexports.uServer = uServer;\n\nclass ResponseWrapper {\n  constructor(res) {\n    this.res = res;\n    this.statusWritten = false;\n    this.headers = [];\n    this.isAborted = false;\n  }\n\n  set statusCode(status) {\n    if (!status) {\n      return;\n    } // FIXME: handle all status codes?\n\n\n    this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n  }\n\n  writeHead(status) {\n    this.statusCode = status;\n  }\n\n  setHeader(key, value) {\n    if (Array.isArray(value)) {\n      value.forEach(val => {\n        this.writeHeader(key, val);\n      });\n    } else {\n      this.writeHeader(key, value);\n    }\n  }\n\n  removeHeader() {// FIXME: not implemented\n  } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n\n\n  getHeader() {}\n\n  writeStatus(status) {\n    if (this.isAborted) return;\n    this.res.writeStatus(status);\n    this.statusWritten = true;\n    this.writeBufferedHeaders();\n    return this;\n  }\n\n  writeHeader(key, value) {\n    if (this.isAborted) return;\n\n    if (key === \"Content-Length\") {\n      // the content length is automatically added by uWebSockets.js\n      return;\n    }\n\n    if (this.statusWritten) {\n      this.res.writeHeader(key, value);\n    } else {\n      this.headers.push([key, value]);\n    }\n  }\n\n  writeBufferedHeaders() {\n    this.headers.forEach(([key, value]) => {\n      this.res.writeHeader(key, value);\n    });\n  }\n\n  end(data) {\n    if (this.isAborted) return;\n    this.res.cork(() => {\n      if (!this.statusWritten) {\n        // status will be inferred as \"200 OK\"\n        this.writeBufferedHeaders();\n      }\n\n      this.res.end(data);\n    });\n  }\n\n  onData(fn) {\n    if (this.isAborted) return;\n    this.res.onData(fn);\n  }\n\n  onAborted(fn) {\n    if (this.isAborted) return;\n    this.res.onAborted(() => {\n      // Any attempt to use the UWS response object after abort will throw!\n      this.isAborted = true;\n      fn();\n    });\n  }\n\n  cork(fn) {\n    if (this.isAborted) return;\n    this.res.cork(fn);\n  }\n\n}","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/engine.io/build/userver.js"],"names":["Object","defineProperty","exports","value","uServer","debug_1","require","server_1","transports_uws_1","debug","default","BaseServer","init","cleanup","prepare","req","res","method","getMethod","toUpperCase","url","getUrl","params","URLSearchParams","getQuery","_query","fromEntries","entries","headers","forEach","key","connection","remoteAddress","Buffer","from","getRemoteAddressAsText","toString","onAborted","createTransport","transportName","attach","app","options","path","_computePath","any","handleRequest","bind","ws","compression","idleTimeout","maxBackpressure","maxPayloadLength","opts","maxHttpBufferSize","upgrade","handleUpgrade","open","transport","getUserData","socket","writable","emit","message","isBinary","onData","close","code","onClose","_applyMiddlewares","callback","middlewares","length","ResponseWrapper","err","writeHead","errorCode","errorContext","undefined","Server","errorMessages","context","abortRequest","sid","clients","onRequest","closeConnection","handshake","errors","BAD_REQUEST","name","verify","id","client","upgrading","upgraded","maybeUpgrade","writeStatus","getHeader","statusCode","FORBIDDEN","writeHeader","end","JSON","stringify","constructor","statusWritten","isAborted","status","setHeader","Array","isArray","val","removeHeader","writeBufferedHeaders","push","data","cork","fn"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uServer = void 0;\nconst debug_1 = require(\"debug\");\nconst server_1 = require(\"./server\");\nconst transports_uws_1 = require(\"./transports-uws\");\nconst debug = (0, debug_1.default)(\"engine:uws\");\nclass uServer extends server_1.BaseServer {\n    init() { }\n    cleanup() { }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req, res) {\n        req.method = req.getMethod().toUpperCase();\n        req.url = req.getUrl();\n        const params = new URLSearchParams(req.getQuery());\n        req._query = Object.fromEntries(params.entries());\n        req.headers = {};\n        req.forEach((key, value) => {\n            req.headers[key] = value;\n        });\n        req.connection = {\n            remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),\n        };\n        res.onAborted(() => {\n            debug(\"response has been aborted\");\n        });\n    }\n    createTransport(transportName, req) {\n        return new transports_uws_1.default[transportName](req);\n    }\n    /**\n     * Attach the engine to a µWebSockets.js server\n     * @param app\n     * @param options\n     */\n    attach(app /* : TemplatedApp */, options = {}) {\n        const path = this._computePath(options);\n        app\n            .any(path, this.handleRequest.bind(this))\n            //\n            .ws(path, {\n            compression: options.compression,\n            idleTimeout: options.idleTimeout,\n            maxBackpressure: options.maxBackpressure,\n            maxPayloadLength: this.opts.maxHttpBufferSize,\n            upgrade: this.handleUpgrade.bind(this),\n            open: (ws) => {\n                const transport = ws.getUserData().transport;\n                transport.socket = ws;\n                transport.writable = true;\n                transport.emit(\"drain\");\n            },\n            message: (ws, message, isBinary) => {\n                ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());\n            },\n            close: (ws, code, message) => {\n                ws.getUserData().transport.onClose(code, message);\n            },\n        });\n    }\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            return callback();\n        }\n        // needed to buffer headers until the status is computed\n        req.res = new ResponseWrapper(res);\n        super._applyMiddlewares(req, req.res, (err) => {\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            req.res.writeHead();\n            callback(err);\n        });\n    }\n    handleRequest(res, req) {\n        debug('handling \"%s\" http request \"%s\"', req.getMethod(), req.getUrl());\n        this.prepare(req, res);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(req.res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    handleUpgrade(res, req, context) {\n        debug(\"on upgrade\");\n        this.prepare(req, res);\n        req.res = res;\n        const callback = async (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: server_1.Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                this.abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            const id = req._query.sid;\n            let transport;\n            if (id) {\n                const client = this.clients[id];\n                if (!client) {\n                    debug(\"upgrade attempt for closed client\");\n                    res.close();\n                }\n                else if (client.upgrading) {\n                    debug(\"transport has already been trying to upgrade\");\n                    res.close();\n                }\n                else if (client.upgraded) {\n                    debug(\"transport had already been upgraded\");\n                    res.close();\n                }\n                else {\n                    debug(\"upgrading existing transport\");\n                    transport = this.createTransport(req._query.transport, req);\n                    client.maybeUpgrade(transport);\n                }\n            }\n            else {\n                transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext));\n                if (!transport) {\n                    return;\n                }\n            }\n            // calling writeStatus() triggers the flushing of any header added in a middleware\n            req.res.writeStatus(\"101 Switching Protocols\");\n            res.upgrade({\n                transport,\n            }, req.getHeader(\"sec-websocket-key\"), req.getHeader(\"sec-websocket-protocol\"), req.getHeader(\"sec-websocket-extensions\"), context);\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(server_1.Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    abortRequest(res, errorCode, errorContext) {\n        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN\n            ? \"403 Forbidden\"\n            : \"400 Bad Request\";\n        const message = errorContext && errorContext.message\n            ? errorContext.message\n            : server_1.Server.errorMessages[errorCode];\n        res.writeStatus(statusCode);\n        res.writeHeader(\"Content-Type\", \"application/json\");\n        res.end(JSON.stringify({\n            code: errorCode,\n            message,\n        }));\n    }\n}\nexports.uServer = uServer;\nclass ResponseWrapper {\n    constructor(res) {\n        this.res = res;\n        this.statusWritten = false;\n        this.headers = [];\n        this.isAborted = false;\n    }\n    set statusCode(status) {\n        if (!status) {\n            return;\n        }\n        // FIXME: handle all status codes?\n        this.writeStatus(status === 200 ? \"200 OK\" : \"204 No Content\");\n    }\n    writeHead(status) {\n        this.statusCode = status;\n    }\n    setHeader(key, value) {\n        if (Array.isArray(value)) {\n            value.forEach((val) => {\n                this.writeHeader(key, val);\n            });\n        }\n        else {\n            this.writeHeader(key, value);\n        }\n    }\n    removeHeader() {\n        // FIXME: not implemented\n    }\n    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134\n    getHeader() { }\n    writeStatus(status) {\n        if (this.isAborted)\n            return;\n        this.res.writeStatus(status);\n        this.statusWritten = true;\n        this.writeBufferedHeaders();\n        return this;\n    }\n    writeHeader(key, value) {\n        if (this.isAborted)\n            return;\n        if (key === \"Content-Length\") {\n            // the content length is automatically added by uWebSockets.js\n            return;\n        }\n        if (this.statusWritten) {\n            this.res.writeHeader(key, value);\n        }\n        else {\n            this.headers.push([key, value]);\n        }\n    }\n    writeBufferedHeaders() {\n        this.headers.forEach(([key, value]) => {\n            this.res.writeHeader(key, value);\n        });\n    }\n    end(data) {\n        if (this.isAborted)\n            return;\n        this.res.cork(() => {\n            if (!this.statusWritten) {\n                // status will be inferred as \"200 OK\"\n                this.writeBufferedHeaders();\n            }\n            this.res.end(data);\n        });\n    }\n    onData(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onData(fn);\n    }\n    onAborted(fn) {\n        if (this.isAborted)\n            return;\n        this.res.onAborted(() => {\n            // Any attempt to use the UWS response object after abort will throw!\n            this.isAborted = true;\n            fn();\n        });\n    }\n    cork(fn) {\n        if (this.isAborted)\n            return;\n        this.res.cork(fn);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}