{"ast":null,"code":"\"use strict\"; // imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\n/**\n * Module dependencies.\n */\n\nvar utf8 = require('./utf8');\n/**\n * Current protocol version.\n */\n\n\nexports.protocol = 3;\n\nconst hasBinary = packets => {\n  for (const packet of packets) {\n    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Packet types.\n */\n\n\nexports.packets = {\n  open: 0 // non-ws\n  ,\n  close: 1 // non-ws\n  ,\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */\n\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    return encodeBuffer({\n      type: packet.type,\n      data: arrayBufferToBuffer(packet.data)\n    }, supportsBinary, callback);\n  } // Sending data as a utf-8 string\n\n\n  var encoded = exports.packets[packet.type]; // data fragment is optional\n\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), {\n      strict: false\n    }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n}\n\nexports.encodePacket = encodePacket;\n;\n/**\n * Encode Buffer data\n */\n\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var typeBuffer = Buffer.allocUnsafe(1);\n  typeBuffer[0] = exports.packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\n\nfunction encodeBase64Packet(packet, callback) {\n  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n  var message = 'b' + exports.packets[packet.type];\n  message += data.toString('base64');\n  return callback(message);\n}\n\nexports.encodeBase64Packet = encodeBase64Packet;\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nfunction decodePacket(data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n\n  var type; // String data\n\n  if (typeof data === 'string') {\n    type = data.charAt(0);\n\n    if (type === 'b') {\n      return decodeBase64Packet(data.slice(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n\n      if (data === false) {\n        return err;\n      }\n    }\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.slice(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  } // Binary data\n\n\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return {\n      type: packetslist[type],\n      data: intArray.buffer.slice(1)\n    };\n  }\n\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n\n  type = data[0];\n  return {\n    type: packetslist[type],\n    data: data.slice(1)\n  };\n}\n\nexports.decodePacket = decodePacket;\n;\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, {\n      strict: false\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\n\nfunction decodeBase64Packet(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = Buffer.from(msg.slice(1), 'base64');\n\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n\n    for (var i = 0; i < abv.length; i++) {\n      abv[i] = data[i];\n    } // @ts-ignore\n\n\n    data = abv.buffer;\n  }\n\n  return {\n    type: type,\n    data: data\n  };\n}\n\nexports.decodeBase64Packet = decodeBase64Packet;\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nfunction encodePayload(packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (supportsBinary && hasBinary(packets)) {\n    return encodePayloadAsBinary(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function encodeOne(packet, doneCallback) {\n    encodePacket(packet, supportsBinary, false, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n}\n\nexports.encodePayload = encodePayload;\n;\n\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\n\n\nfunction map(ary, each, done) {\n  const results = new Array(ary.length);\n  let count = 0;\n\n  for (let i = 0; i < ary.length; i++) {\n    each(ary[i], (error, msg) => {\n      results[i] = msg;\n\n      if (++count === ary.length) {\n        done(null, results);\n      }\n    });\n  }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\n\nfunction decodePayload(data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '',\n      n,\n      msg,\n      packet;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    } // @ts-ignore\n\n\n    if (length === '' || length != (n = Number(length))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.slice(i + 1, i + 1 + n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    } // advance cursor\n\n\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n}\n\nexports.decodePayload = decodePayload;\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\n\nfunction bufferToString(buffer) {\n  var str = '';\n\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n\n  return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\n\n\nfunction stringToBuffer(string) {\n  var buf = Buffer.allocUnsafe(string.length);\n\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n\n  return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\n\n\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n  return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\n\n\nfunction encodePayloadAsBinary(packets, callback) {\n  if (!packets.length) {\n    return callback(EMPTY_BUFFER);\n  }\n\n  map(packets, encodeOneBinaryPacket, function (err, results) {\n    return callback(Buffer.concat(results));\n  });\n}\n\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\n;\n\nfunction encodeOneBinaryPacket(p, doneCallback) {\n  function onBinaryPacketEncode(packet) {\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n\n    if (typeof packet === 'string') {\n      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n\n    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n\n  encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\n\n\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n\n    for (i = 1;; i++) {\n      if (bufferTail[i] === 255) break; // 310 = char length of Number.MAX_VALUE\n\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      strLen += '' + bufferTail[i];\n    }\n\n    bufferTail = bufferTail.slice(strLen.length + 1);\n    var msgLength = parseInt(strLen, 10);\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n\n  var total = buffers.length;\n\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(decodePacket(buffer, binaryType, true), i, total);\n  }\n}\n\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n;","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/engine.io/build/parser-v3/index.js"],"names":["Object","defineProperty","exports","value","decodePayloadAsBinary","encodePayloadAsBinary","decodePayload","encodePayload","decodeBase64Packet","decodePacket","encodeBase64Packet","encodePacket","packets","protocol","utf8","require","hasBinary","packet","data","ArrayBuffer","isView","open","close","ping","pong","message","upgrade","noop","packetslist","keys","err","type","EMPTY_BUFFER","Buffer","concat","supportsBinary","utf8encode","callback","isBuffer","encodeBuffer","buffer","arrayBufferToBuffer","encoded","undefined","encode","String","strict","typeBuffer","allocUnsafe","toString","binaryType","utf8decode","charAt","slice","tryDecode","Number","length","intArray","Uint8Array","decode","e","msg","from","abv","i","encodeOne","doneCallback","setLengthHeader","map","results","join","ary","each","done","Array","count","error","n","l","chr","more","bufferToString","str","fromCharCode","stringToBuffer","string","buf","writeUInt8","charCodeAt","byteLength","offset","byteOffset","encodeOneBinaryPacket","p","onBinaryPacketEncode","encodingLength","sizeBuffer","parseInt","bufferTail","buffers","strLen","isString","msgLength","push","total"],"mappings":"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","sourcesContent":["\"use strict\";\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\n/**\n * Module dependencies.\n */\nvar utf8 = require('./utf8');\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\nconst hasBinary = (packets) => {\n    for (const packet of packets) {\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */\nexports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */\nvar err = { type: 'error', data: 'parser error' };\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === 'function') {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    }\n    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n    }\n    return callback('' + encoded);\n}\nexports.encodePacket = encodePacket;\n;\n/**\n * Encode Buffer data\n */\nfunction encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\nfunction encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = 'b' + exports.packets[packet.type];\n    message += data.toString('base64');\n    return callback(message);\n}\nexports.encodeBase64Packet = encodeBase64Packet;\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\nfunction decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === 'string') {\n        type = data.charAt(0);\n        if (type === 'b') {\n            return decodeBase64Packet(data.slice(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return { type: packetslist[type], data: data.slice(1) };\n        }\n        else {\n            return { type: packetslist[type] };\n        }\n    }\n    // Binary data\n    if (binaryType === 'arraybuffer') {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return { type: packetslist[type], data: intArray.buffer.slice(1) };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return { type: packetslist[type], data: data.slice(1) };\n}\nexports.decodePacket = decodePacket;\n;\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, { strict: false });\n    }\n    catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\nfunction decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.slice(1), 'base64');\n    if (binaryType === 'arraybuffer') {\n        var abv = new Uint8Array(data.length);\n        for (var i = 0; i < abv.length; i++) {\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return { type: type, data: data };\n}\nexports.decodeBase64Packet = decodeBase64Packet;\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\nfunction encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback('0:');\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function (message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function (err, results) {\n        return callback(results.join(''));\n    });\n}\nexports.encodePayload = encodePayload;\n;\nfunction setLengthHeader(message) {\n    return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\nfunction map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for (let i = 0; i < ary.length; i++) {\n        each(ary[i], (error, msg) => {\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\nfunction decodePayload(data, binaryType, callback) {\n    if (typeof data !== 'string') {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = '', n, msg, packet;\n    for (var i = 0, l = data.length; i < l; i++) {\n        var chr = data.charAt(i);\n        if (chr !== ':') {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === '' || (length != (n = Number(length)))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.slice(i + 1, i + 1 + n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more)\n                return;\n        }\n        // advance cursor\n        i += n;\n        length = '';\n    }\n    if (length !== '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\nexports.decodePayload = decodePayload;\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\nfunction bufferToString(buffer) {\n    var str = '';\n    for (var i = 0, l = buffer.length; i < l; i++) {\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\nfunction stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for (var i = 0, l = string.length; i < l; i++) {\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\nfunction arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\nfunction encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function (err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = '' + packet.length;\n        var sizeBuffer;\n        if (typeof packet === 'string') {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for (var i = 0; i < encodingLength.length; i++) {\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for (var i = 0; i < encodingLength.length; i++) {\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while (bufferTail.length > 0) {\n        var strLen = '';\n        var isString = bufferTail[0] === 0;\n        for (i = 1;; i++) {\n            if (bufferTail[i] === 255)\n                break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += '' + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString)\n            msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for (i = 0; i < total; i++) {\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n;\n"]},"metadata":{},"sourceType":"script"}