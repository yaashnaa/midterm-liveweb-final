{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\n\nconst namespace_1 = require(\"./namespace\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\n\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\n   * @private\n   */\n\n\n  _initAdapter() {\n    const broadcast = (packet, opts) => {\n      this.children.forEach(nsp => {\n        nsp.adapter.broadcast(packet, opts);\n      });\n    }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n\n\n    this.adapter = {\n      broadcast\n    };\n  }\n\n  emit(ev, ...args) {\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n\n  createChild(name) {\n    debug(\"creating child namespace %s\", name);\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n\n    if (this.server._opts.cleanupEmptyChildNamespaces) {\n      const remove = namespace._remove;\n\n      namespace._remove = socket => {\n        remove.call(namespace, socket);\n\n        if (namespace.sockets.size === 0) {\n          debug(\"closing child namespace %s\", name);\n          namespace.adapter.close();\n\n          this.server._nsps.delete(namespace.name);\n\n          this.children.delete(namespace);\n        }\n      };\n    }\n\n    this.server._nsps.set(name, namespace); // @ts-ignore\n\n\n    this.server.sockets.emitReserved(\"new_namespace\", namespace);\n    return namespace;\n  }\n\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n\n}\n\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/socket.io/dist/parent-namespace.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","debug_1","debug","default","Namespace","constructor","server","count","children","Set","_initAdapter","broadcast","packet","opts","forEach","nsp","adapter","emit","ev","args","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_opts","cleanupEmptyChildNamespaces","remove","_remove","socket","call","sockets","size","close","_nsps","delete","set","emitReserved","fetchSockets","Error"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMC,OAAO,GAAGV,eAAe,CAACS,OAAO,CAAC,OAAD,CAAR,CAA/B;;AACA,MAAME,KAAK,GAAG,CAAC,GAAGD,OAAO,CAACE,OAAZ,EAAqB,4BAArB,CAAd;AACA;;;;;;;;;;;;;;;;AAeA,MAAML,eAAN,SAA8BC,WAAW,CAACK,SAA1C,CAAoD;AAChDC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,UAAMA,MAAN,EAAc,OAAOR,eAAe,CAACS,KAAhB,EAArB;AACA,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACH;AACD;;;;;AAGAC,EAAAA,YAAY,GAAG;AACX,UAAMC,SAAS,GAAG,CAACC,MAAD,EAASC,IAAT,KAAkB;AAChC,WAAKL,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;AAC3BA,QAAAA,GAAG,CAACC,OAAJ,CAAYL,SAAZ,CAAsBC,MAAtB,EAA8BC,IAA9B;AACH,OAFD;AAGH,KAJD,CADW,CAMX;;;AACA,SAAKG,OAAL,GAAe;AAAEL,MAAAA;AAAF,KAAf;AACH;;AACDM,EAAAA,IAAI,CAACC,EAAD,EAAK,GAAGC,IAAR,EAAc;AACd,SAAKX,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;AAC3BA,MAAAA,GAAG,CAACE,IAAJ,CAASC,EAAT,EAAa,GAAGC,IAAhB;AACH,KAFD;AAGA,WAAO,IAAP;AACH;;AACDC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACdnB,IAAAA,KAAK,CAAC,6BAAD,EAAgCmB,IAAhC,CAAL;AACA,UAAMC,SAAS,GAAG,IAAIvB,WAAW,CAACK,SAAhB,CAA0B,KAAKE,MAA/B,EAAuCe,IAAvC,CAAlB;AACAC,IAAAA,SAAS,CAACC,IAAV,GAAiB,KAAKA,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAjB;AACA,SAAKC,SAAL,CAAe,SAAf,EAA0BX,OAA1B,CAAmCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,SAAb,EAAwBD,QAAxB,CAAhD;AACA,SAAKD,SAAL,CAAe,YAAf,EAA6BX,OAA7B,CAAsCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,YAAb,EAA2BD,QAA3B,CAAnD;AACA,SAAKlB,QAAL,CAAcoB,GAAd,CAAkBN,SAAlB;;AACA,QAAI,KAAKhB,MAAL,CAAYuB,KAAZ,CAAkBC,2BAAtB,EAAmD;AAC/C,YAAMC,MAAM,GAAGT,SAAS,CAACU,OAAzB;;AACAV,MAAAA,SAAS,CAACU,OAAV,GAAqBC,MAAD,IAAY;AAC5BF,QAAAA,MAAM,CAACG,IAAP,CAAYZ,SAAZ,EAAuBW,MAAvB;;AACA,YAAIX,SAAS,CAACa,OAAV,CAAkBC,IAAlB,KAA2B,CAA/B,EAAkC;AAC9BlC,UAAAA,KAAK,CAAC,4BAAD,EAA+BmB,IAA/B,CAAL;AACAC,UAAAA,SAAS,CAACN,OAAV,CAAkBqB,KAAlB;;AACA,eAAK/B,MAAL,CAAYgC,KAAZ,CAAkBC,MAAlB,CAAyBjB,SAAS,CAACD,IAAnC;;AACA,eAAKb,QAAL,CAAc+B,MAAd,CAAqBjB,SAArB;AACH;AACJ,OARD;AASH;;AACD,SAAKhB,MAAL,CAAYgC,KAAZ,CAAkBE,GAAlB,CAAsBnB,IAAtB,EAA4BC,SAA5B,EAnBc,CAoBd;;;AACA,SAAKhB,MAAL,CAAY6B,OAAZ,CAAoBM,YAApB,CAAiC,eAAjC,EAAkDnB,SAAlD;AACA,WAAOA,SAAP;AACH;;AACDoB,EAAAA,YAAY,GAAG;AACX;AACA;AACA;AACA;AACA;AACA,UAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;AACH;;AAtD+C;;AAwDpD/C,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAA,eAAe,CAACS,KAAhB,GAAwB,CAAxB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = (0, debug_1.default)(\"socket.io:parent-namespace\");\n/**\n * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either\n * with a regular expression or with a function.\n *\n * @example\n * const parentNamespace = io.of(/\\/dynamic-\\d+/);\n *\n * parentNamespace.on(\"connection\", (socket) => {\n *   const childNamespace = socket.nsp;\n * }\n *\n * // will reach all the clients that are in one of the child namespaces, like \"/dynamic-101\"\n * parentNamespace.emit(\"hello\", \"world\");\n *\n */\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        const broadcast = (packet, opts) => {\n            this.children.forEach((nsp) => {\n                nsp.adapter.broadcast(packet, opts);\n            });\n        };\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n        this.adapter = { broadcast };\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        debug(\"creating child namespace %s\", name);\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        if (this.server._opts.cleanupEmptyChildNamespaces) {\n            const remove = namespace._remove;\n            namespace._remove = (socket) => {\n                remove.call(namespace, socket);\n                if (namespace.sockets.size === 0) {\n                    debug(\"closing child namespace %s\", name);\n                    namespace.adapter.close();\n                    this.server._nsps.delete(namespace.name);\n                    this.children.delete(namespace);\n                }\n            };\n        }\n        this.server._nsps.set(name, namespace);\n        // @ts-ignore\n        this.server.sockets.emitReserved(\"new_namespace\", namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n"]},"metadata":{},"sourceType":"script"}