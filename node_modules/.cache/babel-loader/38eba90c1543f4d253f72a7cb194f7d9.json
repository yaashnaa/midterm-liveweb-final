{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebSocket = void 0;\n\nconst transport_1 = require(\"../transport\");\n\nconst debug_1 = require(\"debug\");\n\nconst debug = (0, debug_1.default)(\"engine:ws\");\n\nclass WebSocket extends transport_1.Transport {\n  /**\n   * WebSocket transport\n   *\n   * @param {http.IncomingMessage}\n   * @api public\n   */\n  constructor(req) {\n    super(req);\n    this.socket = req.websocket;\n    this.socket.on(\"message\", (data, isBinary) => {\n      const message = isBinary ? data : data.toString();\n      debug('received \"%s\"', message);\n      super.onData(message);\n    });\n    this.socket.once(\"close\", this.onClose.bind(this));\n    this.socket.on(\"error\", this.onError.bind(this));\n    this.writable = true;\n    this.perMessageDeflate = null;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"websocket\";\n  }\n  /**\n   * Advertise upgrade support.\n   *\n   * @api public\n   */\n\n\n  get handlesUpgrades() {\n    return true;\n  }\n  /**\n   * Advertise framing support.\n   *\n   * @api public\n   */\n\n\n  get supportsFraming() {\n    return true;\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Array} packets\n   * @api private\n   */\n\n\n  send(packets) {\n    this.writable = false;\n\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const isLast = i + 1 === packets.length; // always creates a new object since ws modifies it\n\n      const opts = {};\n\n      if (packet.options) {\n        opts.compress = packet.options.compress;\n      }\n\n      const onSent = err => {\n        if (err) {\n          return this.onError(\"write error\", err.stack);\n        } else if (isLast) {\n          this.writable = true;\n          this.emit(\"drain\");\n        }\n      };\n\n      const send = data => {\n        if (this.perMessageDeflate) {\n          const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n          if (len < this.perMessageDeflate.threshold) {\n            opts.compress = false;\n          }\n        }\n\n        debug('writing \"%s\"', data);\n        this.socket.send(data, opts, onSent);\n      };\n\n      if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n        send(packet.options.wsPreEncoded);\n      } else if (this._canSendPreEncodedFrame(packet)) {\n        // the WebSocket frame was computed with WebSocket.Sender.frame()\n        // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n        this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);\n      } else {\n        this.parser.encodePacket(packet, this.supportsBinary, send);\n      }\n    }\n  }\n  /**\n   * Whether the encoding of the WebSocket frame can be skipped.\n   * @param packet\n   * @private\n   */\n\n\n  _canSendPreEncodedFrame(packet) {\n    var _a, _b, _c;\n\n    return !this.perMessageDeflate && typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" && ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined;\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    this.socket.close();\n    fn && fn();\n  }\n\n}\n\nexports.WebSocket = WebSocket;","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/engine.io/build/transports/websocket.js"],"names":["Object","defineProperty","exports","value","WebSocket","transport_1","require","debug_1","debug","default","Transport","constructor","req","socket","websocket","on","data","isBinary","message","toString","onData","once","onClose","bind","onError","writable","perMessageDeflate","name","handlesUpgrades","supportsFraming","send","packets","i","length","packet","isLast","opts","options","compress","onSent","err","stack","emit","len","Buffer","byteLength","threshold","wsPreEncoded","_canSendPreEncodedFrame","_sender","sendFrame","wsPreEncodedFrame","parser","encodePacket","supportsBinary","_a","_b","_c","undefined","doClose","fn","close"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebSocket = void 0;\nconst transport_1 = require(\"../transport\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:ws\");\nclass WebSocket extends transport_1.Transport {\n    /**\n     * WebSocket transport\n     *\n     * @param {http.IncomingMessage}\n     * @api public\n     */\n    constructor(req) {\n        super(req);\n        this.socket = req.websocket;\n        this.socket.on(\"message\", (data, isBinary) => {\n            const message = isBinary ? data : data.toString();\n            debug('received \"%s\"', message);\n            super.onData(message);\n        });\n        this.socket.once(\"close\", this.onClose.bind(this));\n        this.socket.on(\"error\", this.onError.bind(this));\n        this.writable = true;\n        this.perMessageDeflate = null;\n    }\n    /**\n     * Transport name\n     *\n     * @api public\n     */\n    get name() {\n        return \"websocket\";\n    }\n    /**\n     * Advertise upgrade support.\n     *\n     * @api public\n     */\n    get handlesUpgrades() {\n        return true;\n    }\n    /**\n     * Advertise framing support.\n     *\n     * @api public\n     */\n    get supportsFraming() {\n        return true;\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Array} packets\n     * @api private\n     */\n    send(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const isLast = i + 1 === packets.length;\n            // always creates a new object since ws modifies it\n            const opts = {};\n            if (packet.options) {\n                opts.compress = packet.options.compress;\n            }\n            const onSent = (err) => {\n                if (err) {\n                    return this.onError(\"write error\", err.stack);\n                }\n                else if (isLast) {\n                    this.writable = true;\n                    this.emit(\"drain\");\n                }\n            };\n            const send = (data) => {\n                if (this.perMessageDeflate) {\n                    const len = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                    if (len < this.perMessageDeflate.threshold) {\n                        opts.compress = false;\n                    }\n                }\n                debug('writing \"%s\"', data);\n                this.socket.send(data, opts, onSent);\n            };\n            if (packet.options && typeof packet.options.wsPreEncoded === \"string\") {\n                send(packet.options.wsPreEncoded);\n            }\n            else if (this._canSendPreEncodedFrame(packet)) {\n                // the WebSocket frame was computed with WebSocket.Sender.frame()\n                // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n                this.socket._sender.sendFrame(packet.options.wsPreEncodedFrame, onSent);\n            }\n            else {\n                this.parser.encodePacket(packet, this.supportsBinary, send);\n            }\n        }\n    }\n    /**\n     * Whether the encoding of the WebSocket frame can be skipped.\n     * @param packet\n     * @private\n     */\n    _canSendPreEncodedFrame(packet) {\n        var _a, _b, _c;\n        return (!this.perMessageDeflate &&\n            typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0 ? void 0 : _b.sendFrame) === \"function\" &&\n            ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        this.socket.close();\n        fn && fn();\n    }\n}\nexports.WebSocket = WebSocket;\n"]},"metadata":{},"sourceType":"script"}