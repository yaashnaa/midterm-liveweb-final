{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream } from \"engine.io-parser\";\nexport class WT extends Transport {\n  get name() {\n    return \"webtransport\";\n  }\n\n  doOpen() {\n    // @ts-ignore\n    if (typeof WebTransport !== \"function\") {\n      return;\n    } // @ts-ignore\n\n\n    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    this.transport.closed.then(() => {\n      this.onClose();\n    }).catch(err => {\n      this.onError(\"webtransport error\", err);\n    }); // note: we could have used async/await, but that would require some additional polyfills\n\n    this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then(stream => {\n        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n        const reader = stream.readable.pipeThrough(decoderStream).getReader();\n        const encoderStream = createPacketEncoderStream();\n        encoderStream.readable.pipeTo(stream.writable);\n        this.writer = encoderStream.writable.getWriter();\n\n        const read = () => {\n          reader.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              return;\n            }\n\n            this.onPacket(value);\n            read();\n          }).catch(err => {});\n        };\n\n        read();\n        const packet = {\n          type: \"open\"\n        };\n\n        if (this.query.sid) {\n          packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n        }\n\n        this.writer.write(packet).then(() => this.onOpen());\n      });\n    });\n  }\n\n  write(packets) {\n    this.writable = false;\n\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      this.writer.write(packet).then(() => {\n        if (lastPacket) {\n          nextTick(() => {\n            this.writable = true;\n            this.emitReserved(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n\n  doClose() {\n    var _a;\n\n    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n\n}","map":{"version":3,"sources":["/Users/yashna/Desktop/midterm-liveweb/node_modules/engine.io-client/build/esm/transports/webtransport.js"],"names":["Transport","nextTick","createPacketDecoderStream","createPacketEncoderStream","WT","name","doOpen","WebTransport","transport","createUri","opts","transportOptions","closed","then","onClose","catch","err","onError","ready","createBidirectionalStream","stream","decoderStream","Number","MAX_SAFE_INTEGER","socket","binaryType","reader","readable","pipeThrough","getReader","encoderStream","pipeTo","writable","writer","getWriter","read","done","value","onPacket","packet","type","query","sid","data","write","onOpen","packets","i","length","lastPacket","emitReserved","setTimeoutFn","doClose","_a","close"],"mappings":"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","sourcesContent":["import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream, } from \"engine.io-parser\";\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        // @ts-ignore\n        if (typeof WebTransport !== \"function\") {\n            return;\n        }\n        // @ts-ignore\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        this.transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this.transport.ready.then(() => {\n            this.transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = createPacketEncoderStream();\n                encoderStream.readable.pipeTo(stream.writable);\n                this.writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this.writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this.writer.write(packet).then(() => {\n                if (lastPacket) {\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}