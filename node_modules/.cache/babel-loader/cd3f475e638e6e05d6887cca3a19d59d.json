{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = exports.BaseServer = void 0;\n\nconst qs = require(\"querystring\");\n\nconst url_1 = require(\"url\");\n\nconst base64id = require(\"base64id\");\n\nconst transports_1 = require(\"./transports\");\n\nconst events_1 = require(\"events\");\n\nconst socket_1 = require(\"./socket\");\n\nconst debug_1 = require(\"debug\");\n\nconst cookie_1 = require(\"cookie\");\n\nconst ws_1 = require(\"ws\");\n\nconst webtransport_1 = require(\"./transports/webtransport\");\n\nconst engine_io_parser_1 = require(\"engine.io-parser\");\n\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\n\nfunction parseSessionId(data) {\n  try {\n    const parsed = JSON.parse(data);\n\n    if (typeof parsed.sid === \"string\") {\n      return parsed.sid;\n    }\n  } catch (e) {}\n}\n\nclass BaseServer extends events_1.EventEmitter {\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  constructor(opts = {}) {\n    super();\n    this.middlewares = [];\n    this.clients = {};\n    this.clientsCount = 0;\n    this.opts = Object.assign({\n      wsEngine: ws_1.Server,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: [\"polling\", \"websocket\"],\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        // @ts-ignore\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (this.opts.cors) {\n      this.use(require(\"cors\")(this.opts.cors));\n    }\n\n    if (opts.perMessageDeflate) {\n      this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    this.init();\n  }\n  /**\n   * Compute the pathname of the requests that are handled by the server\n   * @param options\n   * @protected\n   */\n\n\n  _computePath(options) {\n    let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n\n    if (options.addTrailingSlash !== false) {\n      // normalize path\n      path += \"/\";\n    }\n\n    return path;\n  }\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n\n\n  upgrades(transport) {\n    if (!this.opts.allowUpgrades) return [];\n    return transports_1.default[transport].upgradesTo || [];\n  }\n  /**\n   * Verifies a request.\n   *\n   * @param {http.IncomingMessage}\n   * @return {Boolean} whether the request is valid\n   * @api private\n   */\n\n\n  verify(req, upgrade, fn) {\n    // transport check\n    const transport = req._query.transport; // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n\n    if (!~this.opts.transports.indexOf(transport) || transport === \"webtransport\") {\n      debug('unknown transport \"%s\"', transport);\n      return fn(Server.errors.UNKNOWN_TRANSPORT, {\n        transport\n      });\n    } // 'Origin' header check\n\n\n    const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n    if (isOriginInvalid) {\n      const origin = req.headers.origin;\n      req.headers.origin = null;\n      debug(\"origin header invalid\");\n      return fn(Server.errors.BAD_REQUEST, {\n        name: \"INVALID_ORIGIN\",\n        origin\n      });\n    } // sid check\n\n\n    const sid = req._query.sid;\n\n    if (sid) {\n      if (!this.clients.hasOwnProperty(sid)) {\n        debug('unknown sid \"%s\"', sid);\n        return fn(Server.errors.UNKNOWN_SID, {\n          sid\n        });\n      }\n\n      const previousTransport = this.clients[sid].transport.name;\n\n      if (!upgrade && previousTransport !== transport) {\n        debug(\"bad request: unexpected transport without upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_MISMATCH\",\n          transport,\n          previousTransport\n        });\n      }\n    } else {\n      // handshake is GET only\n      if (\"GET\" !== req.method) {\n        return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n          method: req.method\n        });\n      }\n\n      if (transport === \"websocket\" && !upgrade) {\n        debug(\"invalid transport upgrade\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\"\n        });\n      }\n\n      if (!this.opts.allowRequest) return fn();\n      return this.opts.allowRequest(req, (message, success) => {\n        if (!success) {\n          return fn(Server.errors.FORBIDDEN, {\n            message\n          });\n        }\n\n        fn();\n      });\n    }\n\n    fn();\n  }\n  /**\n   * Adds a new middleware.\n   *\n   * @example\n   * import helmet from \"helmet\";\n   *\n   * engine.use(helmet());\n   *\n   * @param fn\n   */\n\n\n  use(fn) {\n    this.middlewares.push(fn);\n  }\n  /**\n   * Apply the middlewares to the request.\n   *\n   * @param req\n   * @param res\n   * @param callback\n   * @protected\n   */\n\n\n  _applyMiddlewares(req, res, callback) {\n    if (this.middlewares.length === 0) {\n      debug(\"no middleware to apply, skipping\");\n      return callback();\n    }\n\n    const apply = i => {\n      debug(\"applying middleware nÂ°%d\", i + 1);\n      this.middlewares[i](req, res, err => {\n        if (err) {\n          return callback(err);\n        }\n\n        if (i + 1 < this.middlewares.length) {\n          apply(i + 1);\n        } else {\n          callback();\n        }\n      });\n    };\n\n    apply(0);\n  }\n  /**\n   * Closes all clients.\n   *\n   * @api public\n   */\n\n\n  close() {\n    debug(\"closing all open clients\");\n\n    for (let i in this.clients) {\n      if (this.clients.hasOwnProperty(i)) {\n        this.clients[i].close(true);\n      }\n    }\n\n    this.cleanup();\n    return this;\n  }\n  /**\n   * generate a socket id.\n   * Overwrite this method to generate your custom socket id\n   *\n   * @param {Object} request object\n   * @api public\n   */\n\n\n  generateId(req) {\n    return base64id.generateId();\n  }\n  /**\n   * Handshakes a new client.\n   *\n   * @param {String} transport name\n   * @param {Object} request object\n   * @param {Function} closeConnection\n   *\n   * @api protected\n   */\n\n\n  async handshake(transportName, req, closeConnection) {\n    const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n    if (protocol === 3 && !this.opts.allowEIO3) {\n      debug(\"unsupported protocol version\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n        message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n        context: {\n          protocol\n        }\n      });\n      closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n      return;\n    }\n\n    let id;\n\n    try {\n      id = await this.generateId(req);\n    } catch (e) {\n      debug(\"error while generating an id\");\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"ID_GENERATION_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    debug('handshaking client \"%s\"', id);\n\n    try {\n      var transport = this.createTransport(transportName, req);\n\n      if (\"polling\" === transportName) {\n        transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n        transport.httpCompression = this.opts.httpCompression;\n      } else if (\"websocket\" === transportName) {\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n      }\n\n      if (req._query && req._query.b64) {\n        transport.supportsBinary = false;\n      } else {\n        transport.supportsBinary = true;\n      }\n    } catch (e) {\n      debug('error handshaking to transport \"%s\"', transportName);\n      this.emit(\"connection_error\", {\n        req,\n        code: Server.errors.BAD_REQUEST,\n        message: Server.errorMessages[Server.errors.BAD_REQUEST],\n        context: {\n          name: \"TRANSPORT_HANDSHAKE_ERROR\",\n          error: e\n        }\n      });\n      closeConnection(Server.errors.BAD_REQUEST);\n      return;\n    }\n\n    const socket = new socket_1.Socket(id, this, transport, req, protocol);\n    transport.on(\"headers\", (headers, req) => {\n      const isInitialRequest = !req._query.sid;\n\n      if (isInitialRequest) {\n        if (this.opts.cookie) {\n          headers[\"Set-Cookie\"] = [// @ts-ignore\n          (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)];\n        }\n\n        this.emit(\"initial_headers\", headers, req);\n      }\n\n      this.emit(\"headers\", headers, req);\n    });\n    transport.onRequest(req);\n    this.clients[id] = socket;\n    this.clientsCount++;\n    socket.once(\"close\", () => {\n      delete this.clients[id];\n      this.clientsCount--;\n    });\n    this.emit(\"connection\", socket);\n    return transport;\n  }\n\n  async onWebTransportSession(session) {\n    const timeout = setTimeout(() => {\n      debug(\"the client failed to establish a bidirectional stream in the given period\");\n      session.close();\n    }, this.opts.upgradeTimeout);\n    const streamReader = session.incomingBidirectionalStreams.getReader();\n    const result = await streamReader.read();\n\n    if (result.done) {\n      debug(\"session is closed\");\n      return;\n    }\n\n    const stream = result.value;\n    const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n    const reader = stream.readable.pipeThrough(transformStream).getReader(); // reading the first packet of the stream\n\n    const {\n      value,\n      done\n    } = await reader.read();\n\n    if (done) {\n      debug(\"stream is closed\");\n      return;\n    }\n\n    clearTimeout(timeout);\n\n    if (value.type !== \"open\") {\n      debug(\"invalid WebTransport handshake\");\n      return session.close();\n    }\n\n    if (value.data === undefined) {\n      const transport = new webtransport_1.WebTransport(session, stream, reader); // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n\n      const id = base64id.generateId();\n      debug('handshaking client \"%s\" (WebTransport)', id);\n      const socket = new socket_1.Socket(id, this, transport, null, 4);\n      this.clients[id] = socket;\n      this.clientsCount++;\n      socket.once(\"close\", () => {\n        delete this.clients[id];\n        this.clientsCount--;\n      });\n      this.emit(\"connection\", socket);\n      return;\n    }\n\n    const sid = parseSessionId(value.data);\n\n    if (!sid) {\n      debug(\"invalid WebTransport handshake\");\n      return session.close();\n    }\n\n    const client = this.clients[sid];\n\n    if (!client) {\n      debug(\"upgrade attempt for closed client\");\n      session.close();\n    } else if (client.upgrading) {\n      debug(\"transport has already been trying to upgrade\");\n      session.close();\n    } else if (client.upgraded) {\n      debug(\"transport had already been upgraded\");\n      session.close();\n    } else {\n      debug(\"upgrading existing transport\");\n      const transport = new webtransport_1.WebTransport(session, stream, reader);\n      client.maybeUpgrade(transport);\n    }\n  }\n\n}\n\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\n\nBaseServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\n\nclass WebSocketResponse {\n  constructor(req, socket) {\n    this.req = req;\n    this.socket = socket; // temporarily store the response headers on the req object (see the \"headers\" event)\n\n    req[kResponseHeaders] = {};\n  }\n\n  setHeader(name, value) {\n    this.req[kResponseHeaders][name] = value;\n  }\n\n  getHeader(name) {\n    return this.req[kResponseHeaders][name];\n  }\n\n  removeHeader(name) {\n    delete this.req[kResponseHeaders][name];\n  }\n\n  write() {}\n\n  writeHead() {}\n\n  end() {\n    // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n    this.socket.destroy();\n  }\n\n}\n\nclass Server extends BaseServer {\n  /**\n   * Initialize websocket server\n   *\n   * @api protected\n   */\n  init() {\n    if (!~this.opts.transports.indexOf(\"websocket\")) return;\n    if (this.ws) this.ws.close();\n    this.ws = new this.opts.wsEngine({\n      noServer: true,\n      clientTracking: false,\n      perMessageDeflate: this.opts.perMessageDeflate,\n      maxPayload: this.opts.maxHttpBufferSize\n    });\n\n    if (typeof this.ws.on === \"function\") {\n      this.ws.on(\"headers\", (headersArray, req) => {\n        // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n        // we could also try to parse the array and then sync the values, but that will be error-prone\n        const additionalHeaders = req[kResponseHeaders] || {};\n        delete req[kResponseHeaders];\n        const isInitialRequest = !req._query.sid;\n\n        if (isInitialRequest) {\n          this.emit(\"initial_headers\", additionalHeaders, req);\n        }\n\n        this.emit(\"headers\", additionalHeaders, req);\n        debug(\"writing headers: %j\", additionalHeaders);\n        Object.keys(additionalHeaders).forEach(key => {\n          headersArray.push(`${key}: ${additionalHeaders[key]}`);\n        });\n      });\n    }\n  }\n\n  cleanup() {\n    if (this.ws) {\n      debug(\"closing webSocketServer\");\n      this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n    }\n  }\n  /**\n   * Prepares a request by processing the query string.\n   *\n   * @api private\n   */\n\n\n  prepare(req) {\n    // try to leverage pre-existing `req._query` (e.g: from connect)\n    if (!req._query) {\n      req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n    }\n  }\n\n  createTransport(transportName, req) {\n    return new transports_1.default[transportName](req);\n  }\n  /**\n   * Handles an Engine.IO HTTP request.\n   *\n   * @param {IncomingMessage} req\n   * @param {ServerResponse} res\n   * @api public\n   */\n\n\n  handleRequest(req, res) {\n    debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n    this.prepare(req); // @ts-ignore\n\n    req.res = res;\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortRequest(res, errorCode, errorContext);\n        return;\n      } // @ts-ignore\n\n\n      if (req._query.sid) {\n        debug(\"setting new request for existing client\"); // @ts-ignore\n\n        this.clients[req._query.sid].transport.onRequest(req);\n      } else {\n        const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext); // @ts-ignore\n\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n    };\n\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    });\n  }\n  /**\n   * Handles an Engine.IO HTTP Upgrade.\n   *\n   * @api public\n   */\n\n\n  handleUpgrade(req, socket, upgradeHead) {\n    this.prepare(req);\n    const res = new WebSocketResponse(req, socket);\n\n    const callback = (errorCode, errorContext) => {\n      if (errorCode !== undefined) {\n        this.emit(\"connection_error\", {\n          req,\n          code: errorCode,\n          message: Server.errorMessages[errorCode],\n          context: errorContext\n        });\n        abortUpgrade(socket, errorCode, errorContext);\n        return;\n      }\n\n      const head = Buffer.from(upgradeHead);\n      upgradeHead = null; // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n      // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n\n      res.writeHead(); // delegate to ws\n\n      this.ws.handleUpgrade(req, socket, head, websocket => {\n        this.onWebSocket(req, socket, websocket);\n      });\n    };\n\n    this._applyMiddlewares(req, res, err => {\n      if (err) {\n        callback(Server.errors.BAD_REQUEST, {\n          name: \"MIDDLEWARE_FAILURE\"\n        });\n      } else {\n        this.verify(req, true, callback);\n      }\n    });\n  }\n  /**\n   * Called upon a ws.io connection.\n   *\n   * @param {ws.Socket} websocket\n   * @api private\n   */\n\n\n  onWebSocket(req, socket, websocket) {\n    websocket.on(\"error\", onUpgradeError);\n\n    if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n      debug(\"transport doesnt handle upgraded requests\");\n      websocket.close();\n      return;\n    } // get client id\n\n\n    const id = req._query.sid; // keep a reference to the ws.Socket\n\n    req.websocket = websocket;\n\n    if (id) {\n      const client = this.clients[id];\n\n      if (!client) {\n        debug(\"upgrade attempt for closed client\");\n        websocket.close();\n      } else if (client.upgrading) {\n        debug(\"transport has already been trying to upgrade\");\n        websocket.close();\n      } else if (client.upgraded) {\n        debug(\"transport had already been upgraded\");\n        websocket.close();\n      } else {\n        debug(\"upgrading existing transport\"); // transport error handling takes over\n\n        websocket.removeListener(\"error\", onUpgradeError);\n        const transport = this.createTransport(req._query.transport, req);\n\n        if (req._query && req._query.b64) {\n          transport.supportsBinary = false;\n        } else {\n          transport.supportsBinary = true;\n        }\n\n        transport.perMessageDeflate = this.opts.perMessageDeflate;\n        client.maybeUpgrade(transport);\n      }\n    } else {\n      const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n\n      this.handshake(req._query.transport, req, closeConnection);\n    }\n\n    function onUpgradeError() {\n      debug(\"websocket error before upgrade\"); // websocket.close() not needed\n    }\n  }\n  /**\n   * Captures upgrade requests for a http.Server.\n   *\n   * @param {http.Server} server\n   * @param {Object} options\n   * @api public\n   */\n\n\n  attach(server, options = {}) {\n    const path = this._computePath(options);\n\n    const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n\n    function check(req) {\n      // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n      return path === req.url.slice(0, path.length);\n    } // cache and clean up listeners\n\n\n    const listeners = server.listeners(\"request\").slice(0);\n    server.removeAllListeners(\"request\");\n    server.on(\"close\", this.close.bind(this));\n    server.on(\"listening\", this.init.bind(this)); // add request handler\n\n    server.on(\"request\", (req, res) => {\n      if (check(req)) {\n        debug('intercepting request for path \"%s\"', path);\n        this.handleRequest(req, res);\n      } else {\n        let i = 0;\n        const l = listeners.length;\n\n        for (; i < l; i++) {\n          listeners[i].call(server, req, res);\n        }\n      }\n    });\n\n    if (~this.opts.transports.indexOf(\"websocket\")) {\n      server.on(\"upgrade\", (req, socket, head) => {\n        if (check(req)) {\n          this.handleUpgrade(req, socket, head);\n        } else if (false !== options.destroyUpgrade) {\n          // default node behavior is to disconnect when no handlers\n          // but by adding a handler, we prevent that\n          // and if no eio thing handles the upgrade\n          // then the socket needs to die!\n          setTimeout(function () {\n            // @ts-ignore\n            if (socket.writable && socket.bytesWritten <= 0) {\n              socket.on(\"error\", e => {\n                debug(\"error while destroying upgrade: %s\", e.message);\n              });\n              return socket.end();\n            }\n          }, destroyUpgradeTimeout);\n        }\n      });\n    }\n  }\n\n}\n\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\n\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n  socket.on(\"error\", () => {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    const message = errorContext.message || Server.errorMessages[errorCode];\n    const length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\n\nconst validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (let i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/engine.io/build/server.js"],"names":["Object","defineProperty","exports","value","Server","BaseServer","qs","require","url_1","base64id","transports_1","events_1","socket_1","debug_1","cookie_1","ws_1","webtransport_1","engine_io_parser_1","debug","default","kResponseHeaders","Symbol","parseSessionId","data","parsed","JSON","parse","sid","e","EventEmitter","constructor","opts","middlewares","clients","clientsCount","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","transports","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","use","perMessageDeflate","init","_computePath","options","replace","addTrailingSlash","upgrades","transport","upgradesTo","verify","req","upgrade","fn","_query","indexOf","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","push","_applyMiddlewares","res","callback","length","apply","i","err","close","cleanup","generateId","handshake","transportName","closeConnection","protocol","EIO","emit","code","UNSUPPORTED_PROTOCOL_VERSION","errorMessages","context","id","error","createTransport","b64","supportsBinary","socket","Socket","on","isInitialRequest","serialize","onRequest","once","onWebTransportSession","session","timeout","setTimeout","streamReader","incomingBidirectionalStreams","getReader","result","read","done","stream","transformStream","createPacketDecoderStream","reader","readable","pipeThrough","clearTimeout","type","undefined","WebTransport","client","upgrading","upgraded","maybeUpgrade","WebSocketResponse","setHeader","getHeader","removeHeader","write","writeHead","end","destroy","ws","noServer","clientTracking","maxPayload","headersArray","additionalHeaders","keys","forEach","key","prepare","url","query","handleRequest","errorCode","errorContext","abortRequest","handleUpgrade","upgradeHead","abortUpgrade","head","Buffer","from","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","removeListener","attach","server","destroyUpgradeTimeout","check","slice","listeners","removeAllListeners","bind","l","call","destroyUpgrade","writable","bytesWritten","statusCode","stringify","byteLength","validHdrChars","val","charCodeAt"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Server = exports.BaseServer = void 0;\nconst qs = require(\"querystring\");\nconst url_1 = require(\"url\");\nconst base64id = require(\"base64id\");\nconst transports_1 = require(\"./transports\");\nconst events_1 = require(\"events\");\nconst socket_1 = require(\"./socket\");\nconst debug_1 = require(\"debug\");\nconst cookie_1 = require(\"cookie\");\nconst ws_1 = require(\"ws\");\nconst webtransport_1 = require(\"./transports/webtransport\");\nconst engine_io_parser_1 = require(\"engine.io-parser\");\nconst debug = (0, debug_1.default)(\"engine\");\nconst kResponseHeaders = Symbol(\"responseHeaders\");\nfunction parseSessionId(data) {\n    try {\n        const parsed = JSON.parse(data);\n        if (typeof parsed.sid === \"string\") {\n            return parsed.sid;\n        }\n    }\n    catch (e) { }\n}\nclass BaseServer extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(opts = {}) {\n        super();\n        this.middlewares = [];\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: [\"polling\", \"websocket\"],\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024,\n            },\n            cors: false,\n            allowEIO3: false,\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\",\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.use(require(\"cors\")(this.opts.cors));\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024,\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Compute the pathname of the requests that are handled by the server\n     * @param options\n     * @protected\n     */\n    _computePath(options) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        if (options.addTrailingSlash !== false) {\n            // normalize path\n            path += \"/\";\n        }\n        return path;\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n    upgrades(transport) {\n        if (!this.opts.allowUpgrades)\n            return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n    verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        // WebTransport does not go through the verify() method, see the onWebTransportSession() method\n        if (!~this.opts.transports.indexOf(transport) ||\n            transport === \"webtransport\") {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin,\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid,\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport,\n                });\n            }\n        }\n        else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method,\n                });\n            }\n            if (transport === \"websocket\" && !upgrade) {\n                debug(\"invalid transport upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                });\n            }\n            if (!this.opts.allowRequest)\n                return fn();\n            return this.opts.allowRequest(req, (message, success) => {\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message,\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Adds a new middleware.\n     *\n     * @example\n     * import helmet from \"helmet\";\n     *\n     * engine.use(helmet());\n     *\n     * @param fn\n     */\n    use(fn) {\n        this.middlewares.push(fn);\n    }\n    /**\n     * Apply the middlewares to the request.\n     *\n     * @param req\n     * @param res\n     * @param callback\n     * @protected\n     */\n    _applyMiddlewares(req, res, callback) {\n        if (this.middlewares.length === 0) {\n            debug(\"no middleware to apply, skipping\");\n            return callback();\n        }\n        const apply = (i) => {\n            debug(\"applying middleware nÂ°%d\", i + 1);\n            this.middlewares[i](req, res, (err) => {\n                if (err) {\n                    return callback(err);\n                }\n                if (i + 1 < this.middlewares.length) {\n                    apply(i + 1);\n                }\n                else {\n                    callback();\n                }\n            });\n        };\n        apply(0);\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n    close() {\n        debug(\"closing all open clients\");\n        for (let i in this.clients) {\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        this.cleanup();\n        return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n    generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api protected\n     */\n    async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol,\n                },\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        }\n        catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = this.createTransport(transportName, req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            }\n            else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n            if (req._query && req._query.b64) {\n                transport.supportsBinary = false;\n            }\n            else {\n                transport.supportsBinary = true;\n            }\n        }\n        catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e,\n                },\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req) => {\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", () => {\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n        return transport;\n    }\n    async onWebTransportSession(session) {\n        const timeout = setTimeout(() => {\n            debug(\"the client failed to establish a bidirectional stream in the given period\");\n            session.close();\n        }, this.opts.upgradeTimeout);\n        const streamReader = session.incomingBidirectionalStreams.getReader();\n        const result = await streamReader.read();\n        if (result.done) {\n            debug(\"session is closed\");\n            return;\n        }\n        const stream = result.value;\n        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, \"nodebuffer\");\n        const reader = stream.readable.pipeThrough(transformStream).getReader();\n        // reading the first packet of the stream\n        const { value, done } = await reader.read();\n        if (done) {\n            debug(\"stream is closed\");\n            return;\n        }\n        clearTimeout(timeout);\n        if (value.type !== \"open\") {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        if (value.data === undefined) {\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            // note: we cannot use \"this.generateId()\", because there is no \"req\" argument\n            const id = base64id.generateId();\n            debug('handshaking client \"%s\" (WebTransport)', id);\n            const socket = new socket_1.Socket(id, this, transport, null, 4);\n            this.clients[id] = socket;\n            this.clientsCount++;\n            socket.once(\"close\", () => {\n                delete this.clients[id];\n                this.clientsCount--;\n            });\n            this.emit(\"connection\", socket);\n            return;\n        }\n        const sid = parseSessionId(value.data);\n        if (!sid) {\n            debug(\"invalid WebTransport handshake\");\n            return session.close();\n        }\n        const client = this.clients[sid];\n        if (!client) {\n            debug(\"upgrade attempt for closed client\");\n            session.close();\n        }\n        else if (client.upgrading) {\n            debug(\"transport has already been trying to upgrade\");\n            session.close();\n        }\n        else if (client.upgraded) {\n            debug(\"transport had already been upgraded\");\n            session.close();\n        }\n        else {\n            debug(\"upgrading existing transport\");\n            const transport = new webtransport_1.WebTransport(session, stream, reader);\n            client.maybeUpgrade(transport);\n        }\n    }\n}\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\nBaseServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5,\n};\nBaseServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\",\n};\n/**\n * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade\n * request.\n *\n * @see https://nodejs.org/api/http.html#class-httpserverresponse\n */\nclass WebSocketResponse {\n    constructor(req, socket) {\n        this.req = req;\n        this.socket = socket;\n        // temporarily store the response headers on the req object (see the \"headers\" event)\n        req[kResponseHeaders] = {};\n    }\n    setHeader(name, value) {\n        this.req[kResponseHeaders][name] = value;\n    }\n    getHeader(name) {\n        return this.req[kResponseHeaders][name];\n    }\n    removeHeader(name) {\n        delete this.req[kResponseHeaders][name];\n    }\n    write() { }\n    writeHead() { }\n    end() {\n        // we could return a proper error code, but the WebSocket client will emit an \"error\" event anyway.\n        this.socket.destroy();\n    }\n}\nclass Server extends BaseServer {\n    /**\n     * Initialize websocket server\n     *\n     * @api protected\n     */\n    init() {\n        if (!~this.opts.transports.indexOf(\"websocket\"))\n            return;\n        if (this.ws)\n            this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize,\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req) => {\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = req[kResponseHeaders] || {};\n                delete req[kResponseHeaders];\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                debug(\"writing headers: %j\", additionalHeaders);\n                Object.keys(additionalHeaders).forEach((key) => {\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    cleanup() {\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n            // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    createTransport(transportName, req) {\n        return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {IncomingMessage} req\n     * @param {ServerResponse} res\n     * @api public\n     */\n    handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        // @ts-ignore\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            // @ts-ignore\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                // @ts-ignore\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n                // @ts-ignore\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, false, callback);\n            }\n        });\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n    handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        const res = new WebSocketResponse(req, socket);\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext,\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead);\n            upgradeHead = null;\n            // some middlewares (like express-session) wait for the writeHead() call to flush their headers\n            // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244\n            res.writeHead();\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, (websocket) => {\n                this.onWebSocket(req, socket, websocket);\n            });\n        };\n        this._applyMiddlewares(req, res, (err) => {\n            if (err) {\n                callback(Server.errors.BAD_REQUEST, { name: \"MIDDLEWARE_FAILURE\" });\n            }\n            else {\n                this.verify(req, true, callback);\n            }\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n    onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined &&\n            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            }\n            else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            }\n            else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            }\n            else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = this.createTransport(req._query.transport, req);\n                if (req._query && req._query.b64) {\n                    transport.supportsBinary = false;\n                }\n                else {\n                    transport.supportsBinary = true;\n                }\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n                client.maybeUpgrade(transport);\n            }\n        }\n        else {\n            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n            // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n    attach(server, options = {}) {\n        const path = this._computePath(options);\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        function check(req) {\n            // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)\n            return path === req.url.slice(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res) => {\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            }\n            else {\n                let i = 0;\n                const l = listeners.length;\n                for (; i < l; i++) {\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head) => {\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                }\n                else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function () {\n                        // @ts-ignore\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            socket.on(\"error\", (e) => {\n                                debug(\"error while destroying upgrade: %s\", e.message);\n                            });\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\nfunction abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message,\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", () => {\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" +\n            \"Connection: close\\r\\n\" +\n            \"Content-type: text/html\\r\\n\" +\n            \"Content-Length: \" +\n            length +\n            \"\\r\\n\" +\n            \"\\r\\n\" +\n            message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1)\n        return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2)\n        return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3)\n        return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4)\n        return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for (let i = 4; i < val.length; ++i) {\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}