{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionAwareAdapter = exports.Adapter = void 0;\n\nconst events_1 = require(\"events\");\n\nconst yeast_1 = require(\"./contrib/yeast\");\n\nconst WebSocket = require(\"ws\");\n\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\n\nclass Adapter extends events_1.EventEmitter {\n  /**\n   * In-memory adapter constructor.\n   *\n   * @param {Namespace} nsp\n   */\n  constructor(nsp) {\n    super();\n    this.nsp = nsp;\n    this.rooms = new Map();\n    this.sids = new Map();\n    this.encoder = nsp.server.encoder;\n  }\n  /**\n   * To be overridden\n   */\n\n\n  init() {}\n  /**\n   * To be overridden\n   */\n\n\n  close() {}\n  /**\n   * Returns the number of Socket.IO servers in the cluster\n   *\n   * @public\n   */\n\n\n  serverCount() {\n    return Promise.resolve(1);\n  }\n  /**\n   * Adds a socket to a list of room.\n   *\n   * @param {SocketId}  id      the socket id\n   * @param {Set<Room>} rooms   a set of rooms\n   * @public\n   */\n\n\n  addAll(id, rooms) {\n    if (!this.sids.has(id)) {\n      this.sids.set(id, new Set());\n    }\n\n    for (const room of rooms) {\n      this.sids.get(id).add(room);\n\n      if (!this.rooms.has(room)) {\n        this.rooms.set(room, new Set());\n        this.emit(\"create-room\", room);\n      }\n\n      if (!this.rooms.get(room).has(id)) {\n        this.rooms.get(room).add(id);\n        this.emit(\"join-room\", room, id);\n      }\n    }\n  }\n  /**\n   * Removes a socket from a room.\n   *\n   * @param {SocketId} id     the socket id\n   * @param {Room}     room   the room name\n   */\n\n\n  del(id, room) {\n    if (this.sids.has(id)) {\n      this.sids.get(id).delete(room);\n    }\n\n    this._del(room, id);\n  }\n\n  _del(room, id) {\n    const _room = this.rooms.get(room);\n\n    if (_room != null) {\n      const deleted = _room.delete(id);\n\n      if (deleted) {\n        this.emit(\"leave-room\", room, id);\n      }\n\n      if (_room.size === 0 && this.rooms.delete(room)) {\n        this.emit(\"delete-room\", room);\n      }\n    }\n  }\n  /**\n   * Removes a socket from all rooms it's joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n\n\n  delAll(id) {\n    if (!this.sids.has(id)) {\n      return;\n    }\n\n    for (const room of this.sids.get(id)) {\n      this._del(room, id);\n    }\n\n    this.sids.delete(id);\n  }\n  /**\n   * Broadcasts a packet.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @public\n   */\n\n\n  broadcast(packet, opts) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n\n    const encodedPackets = this._encode(packet, packetOpts);\n\n    this.apply(opts, socket => {\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n  }\n  /**\n   * Broadcasts a packet and expects multiple acknowledgements.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @param clientCountCallback - the number of clients that received the packet\n   * @param ack                 - the callback that will be called for each client response\n   *\n   * @public\n   */\n\n\n  broadcastWithAck(packet, opts, clientCountCallback, ack) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name; // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n\n    packet.id = this.nsp._ids++;\n\n    const encodedPackets = this._encode(packet, packetOpts);\n\n    let clientCount = 0;\n    this.apply(opts, socket => {\n      // track the total number of acknowledgements that are expected\n      clientCount++; // call the ack callback for each client response\n\n      socket.acks.set(packet.id, ack);\n\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n    clientCountCallback(clientCount);\n  }\n\n  _encode(packet, packetOpts) {\n    const encodedPackets = this.encoder.encode(packet);\n\n    if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === \"string\") {\n      // \"4\" being the \"message\" packet type in the Engine.IO protocol\n      const data = Buffer.from(\"4\" + encodedPackets[0]); // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n\n      packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n        readOnly: false,\n        mask: false,\n        rsv1: false,\n        opcode: 1,\n        fin: true\n      });\n    }\n\n    return encodedPackets;\n  }\n  /**\n   * Gets a list of sockets by sid.\n   *\n   * @param {Set<Room>} rooms   the explicit set of rooms to check.\n   */\n\n\n  sockets(rooms) {\n    const sids = new Set();\n    this.apply({\n      rooms\n    }, socket => {\n      sids.add(socket.id);\n    });\n    return Promise.resolve(sids);\n  }\n  /**\n   * Gets the list of rooms a given socket has joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n\n\n  socketRooms(id) {\n    return this.sids.get(id);\n  }\n  /**\n   * Returns the matching socket instances\n   *\n   * @param opts - the filters to apply\n   */\n\n\n  fetchSockets(opts) {\n    const sockets = [];\n    this.apply(opts, socket => {\n      sockets.push(socket);\n    });\n    return Promise.resolve(sockets);\n  }\n  /**\n   * Makes the matching socket instances join the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to join\n   */\n\n\n  addSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      socket.join(rooms);\n    });\n  }\n  /**\n   * Makes the matching socket instances leave the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to leave\n   */\n\n\n  delSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      rooms.forEach(room => socket.leave(room));\n    });\n  }\n  /**\n   * Makes the matching socket instances disconnect\n   *\n   * @param opts - the filters to apply\n   * @param close - whether to close the underlying connection\n   */\n\n\n  disconnectSockets(opts, close) {\n    this.apply(opts, socket => {\n      socket.disconnect(close);\n    });\n  }\n\n  apply(opts, callback) {\n    const rooms = opts.rooms;\n    const except = this.computeExceptSids(opts.except);\n\n    if (rooms.size) {\n      const ids = new Set();\n\n      for (const room of rooms) {\n        if (!this.rooms.has(room)) continue;\n\n        for (const id of this.rooms.get(room)) {\n          if (ids.has(id) || except.has(id)) continue;\n          const socket = this.nsp.sockets.get(id);\n\n          if (socket) {\n            callback(socket);\n            ids.add(id);\n          }\n        }\n      }\n    } else {\n      for (const [id] of this.sids) {\n        if (except.has(id)) continue;\n        const socket = this.nsp.sockets.get(id);\n        if (socket) callback(socket);\n      }\n    }\n  }\n\n  computeExceptSids(exceptRooms) {\n    const exceptSids = new Set();\n\n    if (exceptRooms && exceptRooms.size > 0) {\n      for (const room of exceptRooms) {\n        if (this.rooms.has(room)) {\n          this.rooms.get(room).forEach(sid => exceptSids.add(sid));\n        }\n      }\n    }\n\n    return exceptSids;\n  }\n  /**\n   * Send a packet to the other Socket.IO servers in the cluster\n   * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n   */\n\n\n  serverSideEmit(packet) {\n    console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n  }\n  /**\n   * Save the client session in order to restore it upon reconnection.\n   */\n\n\n  persistSession(session) {}\n  /**\n   * Restore the session and find the packets that were missed by the client.\n   * @param pid\n   * @param offset\n   */\n\n\n  restoreSession(pid, offset) {\n    return null;\n  }\n\n}\n\nexports.Adapter = Adapter;\n\nclass SessionAwareAdapter extends Adapter {\n  constructor(nsp) {\n    super(nsp);\n    this.nsp = nsp;\n    this.sessions = new Map();\n    this.packets = [];\n    this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n    const timer = setInterval(() => {\n      const threshold = Date.now() - this.maxDisconnectionDuration;\n      this.sessions.forEach((session, sessionId) => {\n        const hasExpired = session.disconnectedAt < threshold;\n\n        if (hasExpired) {\n          this.sessions.delete(sessionId);\n        }\n      });\n\n      for (let i = this.packets.length - 1; i >= 0; i--) {\n        const hasExpired = this.packets[i].emittedAt < threshold;\n\n        if (hasExpired) {\n          this.packets.splice(0, i + 1);\n          break;\n        }\n      }\n    }, 60 * 1000); // prevents the timer from keeping the process alive\n\n    timer.unref();\n  }\n\n  persistSession(session) {\n    session.disconnectedAt = Date.now();\n    this.sessions.set(session.pid, session);\n  }\n\n  restoreSession(pid, offset) {\n    const session = this.sessions.get(pid);\n\n    if (!session) {\n      // the session may have expired\n      return null;\n    }\n\n    const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n\n    if (hasExpired) {\n      // the session has expired\n      this.sessions.delete(pid);\n      return null;\n    }\n\n    const index = this.packets.findIndex(packet => packet.id === offset);\n\n    if (index === -1) {\n      // the offset may be too old\n      return null;\n    }\n\n    const missedPackets = [];\n\n    for (let i = index + 1; i < this.packets.length; i++) {\n      const packet = this.packets[i];\n\n      if (shouldIncludePacket(session.rooms, packet.opts)) {\n        missedPackets.push(packet.data);\n      }\n    }\n\n    return Promise.resolve(Object.assign(Object.assign({}, session), {\n      missedPackets\n    }));\n  }\n\n  broadcast(packet, opts) {\n    var _a;\n\n    const isEventPacket = packet.type === 2; // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n    // restored on another server upon reconnection\n\n    const withoutAcknowledgement = packet.id === undefined;\n    const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n\n    if (isEventPacket && withoutAcknowledgement && notVolatile) {\n      const id = (0, yeast_1.yeast)(); // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n      // processed (and the format is backward-compatible)\n\n      packet.data.push(id);\n      this.packets.push({\n        id,\n        opts,\n        data: packet.data,\n        emittedAt: Date.now()\n      });\n    }\n\n    super.broadcast(packet, opts);\n  }\n\n}\n\nexports.SessionAwareAdapter = SessionAwareAdapter;\n\nfunction shouldIncludePacket(sessionRooms, opts) {\n  const included = opts.rooms.size === 0 || sessionRooms.some(room => opts.rooms.has(room));\n  const notExcluded = sessionRooms.every(room => !opts.except.has(room));\n  return included && notExcluded;\n}","map":{"version":3,"sources":["/Users/yashna/Desktop/Llive-code-editor-test/React-CodePen-Clone/node_modules/socket.io-adapter/dist/index.js"],"names":["_a","Object","defineProperty","exports","value","SessionAwareAdapter","Adapter","events_1","require","yeast_1","WebSocket","canPreComputeFrame","Sender","frame","EventEmitter","constructor","nsp","rooms","Map","sids","encoder","server","init","close","serverCount","Promise","resolve","addAll","id","has","set","Set","room","get","add","emit","del","delete","_del","_room","deleted","size","delAll","broadcast","packet","opts","flags","packetOpts","preEncoded","volatile","compress","name","encodedPackets","_encode","apply","socket","notifyOutgoingListeners","client","writeToEngine","broadcastWithAck","clientCountCallback","ack","_ids","clientCount","acks","encode","length","data","Buffer","from","wsPreEncodedFrame","readOnly","mask","rsv1","opcode","fin","sockets","socketRooms","fetchSockets","push","addSockets","join","delSockets","forEach","leave","disconnectSockets","disconnect","callback","except","computeExceptSids","ids","exceptRooms","exceptSids","sid","serverSideEmit","console","warn","persistSession","session","restoreSession","pid","offset","sessions","packets","maxDisconnectionDuration","connectionStateRecovery","timer","setInterval","threshold","Date","now","sessionId","hasExpired","disconnectedAt","i","emittedAt","splice","unref","index","findIndex","missedPackets","shouldIncludePacket","assign","isEventPacket","type","withoutAcknowledgement","undefined","notVolatile","yeast","sessionRooms","included","some","notExcluded","every"],"mappings":"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","sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = require(\"events\");\nconst yeast_1 = require(\"./contrib/yeast\");\nconst WebSocket = require(\"ws\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */\n    constructor(nsp) {\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */\n    init() { }\n    /**\n     * To be overridden\n     */\n    close() { }\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */\n    serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */\n    addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms) {\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */\n    del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)) {\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */\n    broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket) => {\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket) => {\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame &&\n            encodedPackets.length === 1 &&\n            typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true,\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */\n    sockets(rooms) {\n        const sids = new Set();\n        this.apply({ rooms }, (socket) => {\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */\n    fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket) => {\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */\n    addSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */\n    delSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            rooms.forEach((room) => socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(opts, close) {\n        this.apply(opts, (socket) => {\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms) {\n                if (!this.rooms.has(room))\n                    continue;\n                for (const id of this.rooms.get(room)) {\n                    if (ids.has(id) || except.has(id))\n                        continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        }\n        else {\n            for (const [id] of this.sids) {\n                if (except.has(id))\n                    continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket)\n                    callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms) {\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */\n    persistSession(session) { }\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */\n    restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration =\n            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(() => {\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId) => {\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for (let i = this.packets.length - 1; i >= 0; i--) {\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet) => packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for (let i = index + 1; i < this.packets.length; i++) {\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now(),\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));\n    return included && notExcluded;\n}\n"]},"metadata":{},"sourceType":"script"}